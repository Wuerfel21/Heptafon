CON
  _clkfreq = 32_000 * 256 * 16

  spiDO     = 21
  spiClk    = 24
  spiDI     = 20
  spiCS     = 25

  audioLeft = 24+6
  audioRight= 24+7

  vgaBase =  32
  vgaVsync = vgaBase + 4

  volume = 0.18


OBJ
c: "libc"
text: "p2textdrv"

VAR

long filehandle
long sector_rq,sector_ack
long rottotal[4]

byte buffer[1024]

PUB main | rptr,tmp

sector_ack := -1
if vgaBase >= 0
  text.initVga(-1,vgaBase,vgaVsync,0,text.VGA)
  text.setTextColours($F,$1)
  text.clear()
decoderStart(audioLeft,audioRight)
text.printStr(string("HEPTAFON!",13))

'fat.readData(@buffer,1024)
'tv.hex(long[@buffer+$68],8)

c.mount(@"/sd",c._vfs_open_sdcard())
filehandle := c.fopen(@"/sd/suwa.hep",@"rb")

repeat
  if sector_ack <> sector_rq
    rptr := @buffer+(sector_rq&1)<<9
    ifnot c.fread(rptr,512,1,filehandle)
      text.printStr(string("EOF",13))
      return
    sector_ack := sector_rq
    if vgaBase >= 0
      text.home()
      text.nl()
      infoPrint(string("SECTOR"),sector_ack,false)
      tmp := byte[rptr][20]&3
      rottotal[tmp]++
      infoPrint(string("MID"),rottotal[0],tmp==0)
      infoPrint(string("SIDE"),rottotal[1],tmp==1)
      infoPrint(string("LEFT"),rottotal[2],tmp==2)
      infoPrint(string("RIGHT"),rottotal[3],tmp==3)


PRI infoPrint(label,number,highlight)
text.setTextColours($F,highlight?$4:$1)

text.printStr(label)
text.tx(9)
text.tx(":")
text.dec(number)

text.setTextColours($F,$1)
text.nl()

PRI decoderStart(left,right) | divider

divider := clkfreq/32_000
sectorRqPtr := @sector_rq
sectorAckPtr := @sector_ack
musicBufPtr := @buffer

left_pinf := left
right_pinf := right

tempValue1       := P_DAC_75R_2V | P_OE | ((divider&255) ? P_DAC_DITHER_RND : P_DAC_DITHER_PWM)
tempValue2       := divider

cognew(@entry,0)


CON
PRED_SAMPLES = 3
SECTOR_UNITS = 35
UNIT_SAMPLES = 16
SECTOR_SAMPLES = SECTOR_UNITS*UNIT_SAMPLES+PRED_SAMPLES


DAT
              org
entry
              fltl left_pinf
              fltl right_pinf
              wrpin tempValue1,left_pinf
              wrpin tempValue1,right_pinf
              wxpin tempValue2,left_pinf
              wxpin tempValue2,right_pinf
              wypin dacCenter,left_pinf
              wypin dacCenter,right_pinf
              drvl left_pinf
              drvl right_pinf

              mov sectorLeft,sectorLength
loop
              cmp sectorLeft,initThreshold wc
        if_b  jmp #.doDecode
              cmp sectorLeft,sectorLength wz
        if_nz jmp #.no_ptrinit
              ' Check for ACK
              rdlong tempValue1,sectorAckPtr
              cmp tempValue1,sectorCurrent wz
        if_nz jmp #.doOutput ' panicc
              ' Init pointers
              mov uParPtr,musicBufPtr
              test sectorCurrent,#1 wz
        if_nz add uParPtr,bit9
              add uParPtr,#8 ' branch info (NYI)
              ' Prepare next
              mov sectorNext,sectorCurrent
              add sectorNext,#1
              wrlong sectorNext,sectorRqPtr
              ' Get sector parameter
              add uParPtr,#PRED_SAMPLES*4
              rdword sectorPar,uParPtr
              sub uParPtr,#PRED_SAMPLES*4
.no_ptrinit
              rdlong musicOutX,uParPtr
              add uParPtr,#4
              mov musicOutY,musicOutX
              signx musicOutX,#15
              sar musicOutY,#16
              call #pushHistX
              call #pushHistY

              cmp sectorLeft,initThreshold wz
        if_z  add uParPtr,#2
        if_z  mov uDatPtr,uParPtr
        if_z  add uDatPtr,#SECTOR_UNITS*2
              jmp #.sampleDone

.doDecode
              test sectorLeft,#15 wz
        if_nz jmp #.no_unitinit
              rdlong slowData,uDatPtr
              add uDatPtr,#4
              rdword unitPar,uParPtr
              add uParPtr,#2
              mov scaleX,unitPar
              and scaleX,#15
              mov scaleY,unitPar
              shr scaleY,#4
              and scaleY,#15
              shr unitPar,#8
.no_unitinit
              test sectorLeft,#7 wz
        if_z  rdlong fastData,uDatPtr
        if_z  add uDatPtr,#4
              test sectorLeft,#8 wc
  if_c_and_z  mov tempValue1,unitPar
  if_c_and_z  shr tempValue1,#6
  if_c_and_z  sub tempValue1,#2
  if_c_and_z  add scaleX,tempValue1

              ' Generate predictions (unrolled because brrr)
              mov musicOutX,histX0
              test unitPar,#%0011 wcz
        if_nz sumc musicOutX,histX1 ' sub for LINEAR or QUADRATIC, add for WEIGHTED
              test unitPar,#%0010 wz
  if_c_and_nz shl musicOutX,#1 ' QUADRATIC
   if_c_or_nz add musicOutX,histX0 ' LINEAR, QUADRATIC or WEIGHTED
  if_c_and_nz sub musicOutX,histX1 ' QUADRATIC
        if_nz add musicOutX,histX2 ' QUADRATIC or WEIGHTED
 if_nc_and_nz sar musicOutX,#2 ' WEIGHTED

              mov musicOutY,histY0
              test unitPar,#%1100 wcz
        if_nz sumc musicOutY,histY1 ' sub for LINEAR or QUADRATIC, add for WEIGHTED
              test unitPar,#%1000 wz
  if_c_and_nz shl musicOutY,#1 ' QUADRATIC
   if_c_or_nz add musicOutY,histY0 ' LINEAR, QUADRATIC or WEIGHTED
  if_c_and_nz sub musicOutY,histY1 ' QUADRATIC
        if_nz add musicOutY,histY2 ' QUADRATIC or WEIGHTED
 if_nc_and_nz sar musicOutY,#2 ' WEIGHTED


              test unitPar,#%01_0000 wz ' Pre-get lower bit of mode
              test unitPar,#%10_0000 wc
        if_c  jmp #.subsampleMode

              '  Z -> 6bit, NZ -> 3bit
              mov tempValue1,fastData
              shl fastData,#2
              shl slowData,#1 wc
        if_z  rcr tempValue1,#32-4
        if_nz rcr tempValue1,#32-2
              mov tempValue2,fastData
              shl fastData,#2
              shl slowData,#1 wc
              rcr tempValue2,#32-2
        if_z  muxc tempValue1,#16

              ' X delta now in tempValue1, Y delta in tempValue2
              shl tempValue1,scaleX
              cmps histX0,#0 wc
              sumc musicOutX,tempValue1
              shl tempValue2,scaleY
              cmps histY0,#0 wc
        if_nz sumc musicOutY,tempValue2
              push #.sampleDone
              push #pushHistY
              jmp #pushHistX


.subsampleMode
              ' Z -> Y subsampled, NZ -> X subsampled
        if_z  mov tempValue1,fastData
        if_nz mov tempValue2,fastData
        if_z  mov tempValue2,slowData
        if_nz mov tempValue1,slowData

              sar tempValue1,#32-4
              sar tempValue2,#32-4

              ' X delta now in tempValue1, Y delta in tempValue2
              shl tempValue1,scaleX
              cmps histX0,#0 wc
              sumc musicOutX,tempValue1
              shl tempValue2,scaleY
              cmps histY0,#0 wc
              sumc musicOutY,tempValue2

              test sectorLeft,#1 wc ' set C for odd samples
              shl fastData,#4
        if_c  shl slowData,#4
   if_c_or_z  call #pushHistX
   if_c_or_nz call #pushHistY
 if_nc_and_z  add musicOutY,histY0
 if_nc_and_z  sar musicOutY,#1
 if_nc_and_nz add musicOutX,histX0
 if_nc_and_nz sar musicOutX,#1


.sampleDone
              ' advance sectorLeft
              sub sectorLeft,#1 wz
        if_z  mov sectorLeft,sectorLength
        if_z  mov sectorCurrent,sectorNext


.doOutput
              ' Swap XY if need be
              testb sectorPar,#0 wc
        if_c  xor musicOutX,musicOutY
        if_c  xor musicOutY,musicOutX
        if_c  xor musicOutX,musicOutY
              ' Convert mid/side to left/right
              testb sectorPar,#1 wc
              mov musicOutL,musicOutX
        if_nc add musicOutL,musicOutY
              negnc musicOutR,musicOutY
        if_nc add musicOutR,musicOutX
              ' clamp decoded values
              fges musicOutL,clampMin
              fles musicOutL,clampMax
              fges musicOutR,clampMin
              fles musicOutR,clampMax

              ' do output
              mov tempValue1,dacCenter
              mov tempValue2,dacCenter
              scas musicOutL,dacScale
              add tempValue1,0-0
              scas musicOutR,dacScale
              add tempValue2,0-0

              testp right_pinf wc
  if_nc       jmp #$-1
              wypin tempValue1,left_pinf
              wypin tempValue2,right_pinf

              jmp #loop

pushHistX
              mov histX2,histX1
              mov histX1,histX0
        _ret_ mov histX0,musicOutX

pushHistY
              mov histY2,histY1
              mov histY1,histY0
        _ret_ mov histY0,musicOutY


bit31         long |<31
bit9          long |<9
clampMin      long -$7FFF
clampMax      long  $7FFF
dacCenter     long $7F80
dacScale      long round(float($3FC0)*volume)
sectorLength  long SECTOR_SAMPLES
initThreshold long SECTOR_SAMPLES-PRED_SAMPLES+1

sectorCurrent long 0
sectorNext    long 0
sampleCycles  long 0
sectorRqPtr   long 0
sectorAckPtr  long 0
musicBufPtr   long 0
tempValue1    long 0
tempValue2    long 0
tempValue3    long 0
tempValue4    long 0
left_pinf     long 0
right_pinf    long 0
musicOutX     long 0
musicOutY     long 0

sectorPar     res 1
unitPar       res 1
sectorLeft    res 1
uparPtr       res 1
udatPtr       res 1
slowData      res 1
fastData      res 1

scaleX        res 1
scaleY        res 1
musicOutL     res 1
musicOutR     res 1

histX0        res 1 ' previous sample
histX1        res 1 ' the one before that
histX2        res 1 ' the one before that one
histY0        res 1
histY1        res 1
histY2        res 1

              fit 496
